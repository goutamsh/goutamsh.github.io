<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Goutam Shepur</title>
    <link>https://goutamsh.github.io/posts/</link>
    <description>Recent content in Posts on Goutam Shepur</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 08 Apr 2020 17:01:57 +0100</lastBuildDate>
    
	<atom:link href="https://goutamsh.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ELK Stack</title>
      <link>https://goutamsh.github.io/posts/08-04-2010/</link>
      <pubDate>Wed, 08 Apr 2020 17:01:57 +0100</pubDate>
      
      <guid>https://goutamsh.github.io/posts/08-04-2010/</guid>
      <description>ELK Stack is a collection of three open-source products - Elasticsearch, Logstash and Kibana. They are all developed, managed ,and maintained by the company Elastic.
E stands for ElasticSearch: used for storing logs
L stands for LogStash : used for both shipping as well as processing and storing logs
K stands for Kibana: is a visutalization tool (a web interface) which is hosted through Nginx or Apache
Fundamentally if you know how splunk works, it is somewhat functionally similar.</description>
    </item>
    
    <item>
      <title>Monitoring and Observability</title>
      <link>https://goutamsh.github.io/posts/30-03-2020/</link>
      <pubDate>Mon, 30 Mar 2020 00:00:00 +0100</pubDate>
      
      <guid>https://goutamsh.github.io/posts/30-03-2020/</guid>
      <description>When I first came across term Observability I was bit confused how different it is from Monitoring. We used to monitor our application and servers using Splunk and some in-house developed softwares. Let&amp;rsquo;s see how Observability and Monitoring are different.
Monitoring: Monitoring is a verb; something we perform against our applications and systems to determine their state. From basic fitness tests and whether theyâ€™re up or down, to more proactive performance health checks.</description>
    </item>
    
    <item>
      <title>What is CAP Theorem?</title>
      <link>https://goutamsh.github.io/posts/30-07-2019/</link>
      <pubDate>Tue, 30 Jul 2019 23:40:45 +0100</pubDate>
      
      <guid>https://goutamsh.github.io/posts/30-07-2019/</guid>
      <description>CAP = Consistency, Availability and Partition Tolerent
 CAP theorem is generally applicable to distributed systems. In order to cater to heavy workloads we think of scaling out our application by adding additional commodity hardware to system.
 The CAP Theorem states that, in a distributed system (a collection of interconnected nodes that share data.), you can only have two out of the following three guarantees across a write/read pair: Consistency, Availability, and Partition Tolerance - one of them must be sacrificed.</description>
    </item>
    
    <item>
      <title>Software Design Considerations</title>
      <link>https://goutamsh.github.io/posts/26-06-2019/</link>
      <pubDate>Wed, 26 Jun 2019 00:07:45 +0100</pubDate>
      
      <guid>https://goutamsh.github.io/posts/26-06-2019/</guid>
      <description>What are some of the design considerations to keep in mind with regards to software when we have to choose one aspect?
 Share resource and Race condition
If we share resource then we need to consider about race condition scenarion. This is basically in case of multi-threaded environment.
 Centralization and Single Point of Failure
If we think of centralizing some core functionality in one service (for re-usability) or routing traffic through one service (as a proxy or gateway) or basically service which is involved in all data flows, then we need to consider about Single Point of Failure and design for resiliency.</description>
    </item>
    
  </channel>
</rss>